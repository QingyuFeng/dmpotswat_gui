"""
Created on Tue May 12 2020

This class is designed to create watershed and find the contributing
subareas.


@author: Qingyu.Feng
"""

import sys
import os
import pandas
import copy



try:
    from osgeo import ogr, osr, gdal
except:
    sys.exit('ERROR: cannot find GDAL/OGR modules')


##########################################################################
def read_shape_attributes(fin_shapefile):
    """
    Read shapefile and return all values in the
    attritube table.
    :param: fin_shapefile, path of the shapefile
    """

    subarea_attributes = dict()

    driver = ogr.GetDriverByName('ESRI Shapefile')
    data_source = driver.Open(fin_shapefile, 0)
    layer = data_source.GetLayer()

    # Get the field name
    field_names = [field.name for field in layer.schema]

    # Get the value of each field for all layers
    for feature in layer:
        values_list = [str(feature.GetField(j)) for j in field_names]
        subarea_attributes[str(values_list[0])] = values_list

    return field_names, subarea_attributes


##########################################################################
def get_watershed_graph(field_names, subarea_attributes):
    """
    This function read in the attribute table of the shapefile and
    create a graph to represent the watershed.
    The graph wgroupSubForOutlet dictionary, with the reach no as key and upstream
    reach no as values.
    For example, wsGraph = {reachNo: [upStrmNo1, upStrmNo2]}

    For the river generated by the SWAT model, the records are stored
    in the logic of downstream, not upstream.
    So, we need to find the reach no and all its up streams.
    ['OBJECTID', 'ARCID', 'GRID_CODE', 'FROM_NODE', 'TO_NODE',
    'Subbasin', 'SubbasinR', 'AreaC', 'Len2', 'Slo2', 'Wid2',
    'Dep2', 'MinEl', 'MaxEl', 'Shape_Leng', 'HydroID', 'OutletID']
    """

    # Get all stream receiving streams,
    dataframe_reach_attribute = pandas.DataFrame.from_dict(subarea_attributes, orient='index', columns=field_names)

    receiving_reach_no = dataframe_reach_attribute["GRID_CODE"].unique()

    watershed_graph = {}

    for rchID in receiving_reach_no:
        reach_subset = dataframe_reach_attribute[dataframe_reach_attribute["TO_NODE"] == rchID].dropna()["FROM_NODE"]
        if len(list(reach_subset)) > 0:
            watershed_graph[rchID] = list(reach_subset)
        else:
            watershed_graph[rchID] = []

    return watershed_graph, receiving_reach_no


##########################################################################
def get_outlet_in_reach(fin_shapefile):
    '''
    Read shapefile and return all values in the
    attritube table.
    '''
    # Check file existence:
    error_msg = []
    if not os.path.isfile(fin_shapefile):
        error_msg.append('ERROR: Input file does not exist please check!')

    subarea_attribute = dict()

    driver = ogr.GetDriverByName('ESRI Shapefile')
    data_source = driver.Open(fin_shapefile, 0)
    layer = data_source.GetLayer()

    # Get the field name
    field_names = [field.name for field in layer.schema]

    # Get the value of each field for all layers
    for feature in layer:
        values_list = [str(feature.GetField(j)) for j in field_names]
        subarea_attribute[str(values_list[0])] = values_list

    # Convert the dictionary into pandas dataframe
    dataframe_reach_attribute = pandas.DataFrame.from_dict(subarea_attribute,
                                          orient='index',
                                          columns=field_names)

    receiving_reach_nos = dataframe_reach_attribute["GRID_CODE"].unique()

    return receiving_reach_nos


##########################################################################
def groupSubForOutlet(cali_outlets, watershed_graph, all_subarea_nos):
    subarea_groups = {}
    subarea_processed = []

    # Convert the outlet list from number list to string list
    # The allSubLst has all reach no in str.
    outlet_list = list(map(str, cali_outlets))

    for outlet_no in outlet_list:
        temp_group = []
        temp_group, temp_group2 = dfs_iterative(watershed_graph, outlet_no)
        subarea_groups[outlet_no] = temp_group
        subarea_processed = subarea_processed + temp_group

    subarea_not_processed = []
    for subId in all_subarea_nos:
        if not subId in subarea_processed:
            subarea_not_processed.append(subId)

    if len(subarea_not_processed) > 0:
        subarea_groups["not_grouped_subareas"] = subarea_not_processed

    return subarea_groups



##########################################################################
def dfs_iterative(graph, start):
    stack, path, pathminus = [start], [], []

    # Stack as the starting point
    while stack:
        # Signed vertex: for path routing
        signedvertex = stack.pop()
        # remove sign for looping
        vertex = str(abs(int(signedvertex)))
        # Mark vertex as visited.
        if vertex in path:
            continue
        # If not visited, append it.
        path.append(vertex)
        pathminus.append(signedvertex)
        for nbid in range(len(graph[vertex])):
            if nbid > 0:
                neighbor = '-%s' % (graph[vertex][nbid])
            else:
                neighbor = graph[vertex][nbid]

            stack.append(neighbor)

    return path, pathminus


##########################################################################
def dealWithOverlayInSubGroups(subarea_groups):
    """
    This function remove the overlays among subarea groups.
    The main principle is to keep the independency of subarea groups,
    especially those as branches (tributary streams) when they are
    included in the groups for outlets on the main stream.
    """

    subarea_groups_copy = copy.deepcopy(subarea_groups)
    # Commented by Qingyu Feng June 21, 2022
    # Some times, other does not exist since all reaches are processed.
    if "Other" in subarea_groups_copy.keys():
        del (subarea_groups_copy["Other"])
    # Commented by Qingyu Feng June 21, 2022
    subarea_groups_copy2 = copy.deepcopy(subarea_groups_copy)

    subarea_groups_updated = {}

    for subOlt1, subLst1 in subarea_groups_copy.items():
        # print("........processing subgroup for outlet: {}.......".format(subOlt1))
        # subLst1 is for editing
        # subLst2 is for reference.
        tempLst = copy.deepcopy(subLst1)

        for subOlt2, subLst2 in subarea_groups_copy2.items():
            # Exclude comparison between the same outlet
            if subOlt1 != subOlt2:
                # print("comparing between: {} and {}".format(subOlt1, subOlt2))
                # First check whether sublist and sublst2 has overlays.
                if checkCommonInTwoLists(tempLst, subLst2):
                    # If there are common, there will be two cases:
                    # 1. subLst1 > subLst2: subLst1 contains subLst2
                    # 2. subLst1 < subLst2: subLst1 contained by subLst2
                    # The main principle is to maintain the independence
                    # of small lists, due to the facts that it was
                    # for one individual subarea.
                    # Under situation 1: remove elements of subLst2 from
                    # subLst1
                    # Under situation 2: keep subList and do not modify.
                    # print("Overlay found between {} and {}".format(subOlt1, subOlt2))
                    # print("len of subLst1 and subLst2: {} and {}".format(len(tempLst), len(subLst2)))
                    if len(tempLst) > len(subLst2):
                        # print("len before remove extra: {}".format(len(tempLst)))
                        tempLst = removeExtra(tempLst, subLst2)
                        # print("len after remove extra: {}".format(len(tempLst)))

        subarea_groups_updated[subOlt1] = tempLst

    # Commented by Qingyu Feng June 21, 2022
    # Some times, other does not exist since all reaches are processed.
    if "Other" in subarea_groups.keys():
        subarea_groups_updated["Other"] = subarea_groups["Other"]
    # Commented by Qingyu Feng June 21, 2022
    # Check whether the remove succeed:
    # print("..................Checking Overlay results..................")
    # subNoGroupsNoOL2 = copy.deepcopy(subNoGroupUpdated)
    # for subOlt11, subLst11 in subNoGroupUpdated.items():
    #     # subLst1 is for editing
    #     # subLst2 is for reference.
    #     for subOlt22, subLst22 in subNoGroupsNoOL2.items():
    #         # Exclude comparison between the same outlet
    #         if subOlt11 != subOlt22:
    #             # First check whether sublist and sublst2 has overlays.
    #             if checkCommonInTwoLists(subLst11, subLst22):
    #                 print("Overlay found between {} and {}".format(subOlt11, subOlt22))

    return subarea_groups_updated


##########################################################################
def checkCommonInTwoLists(list1, list2):
    """
    This function checks whether there are are common elements
    between list1 and list2.
    Input: two lists
    Output: Boolean:
    """
    one = set(list1)
    two = set(list2)
    if (one & two):
        return True
    else:
        return False


##########################################################################
def removeExtra(list1, list2):
    """
    This function removes the elements in list1 that is also contained in
    list2.
    """
    new_list = []
    for ele1 in list1:
        if not ele1 in list2:
            new_list.append(ele1)

    return new_list